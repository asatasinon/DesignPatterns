# DesignPatterns 设计原则
DesignPatterns 设计原则



# 1. HungrySingleton 饿汉式单例
```java
/**
 * 创建人：Sinon
 * 创建时间：2020/7/20
 * 
 * 5.饿汉式单例
 * 
 * 优点：
 * 执行效率高，性能好，没有任何的锁，线程安全。
 * 
 * 缺点：
 * 1.在某些特殊情况下，可能会造成内存浪费（系统的类过多的情况下，极端一点：几万个类）；
 * 2.可以被 反射 绕过 普通类的 private 构造方法 从而创建出多个实例；
 * 3.可以被 序列化+反序列化 破坏单例，即：json转换
 * 
 * java 类的加载顺序：
 * 先 静态 后 动态
 * 从 上 往 下
 * 先 属性 后 方法
 */
```  

# 2. LazySingleton 懒汉式单例
## 2.1 LazySimpleSingleton 简单懒汉式单例
```java
/**
 * 创建人：Sinon
 * 创建时间：2020/7/20
 * <p>
 * 1.懒汉式单例-非线程安全版
 * <p>
 * 优点：懒加载（第一次调用才初始化），避免内存浪费
 * <p>
 * 缺点：非线程安全，在多线程不能正常工作。
 * 可以被 序列化+反序列化 破坏单例，即：json转换
 */
```
## 2.2 LazySafeSingleton 简单懒汉式单例
```java
/**
 * 创建人：Sinon
 * 创建时间：2020/7/20
 * <p>
 * 2.懒汉式单例-线程安全版
 * <p>
 * 优点：懒加载（第一次调用才初始化），避免内存浪费，线程安全
 * <p>
 * 缺点：性能效率低
 * 可以被 序列化+反序列化 破坏单例，即：json转换
 */
```
## 2.3 LazyDoubleCheckSingleton 
```java
/**
 * 创建人：Sinon
 * 创建时间：2020/7/20
 * <p>
 * 3.懒汉式单例-双重校验版
 * 双重校验锁（DCL，即 double-checked locking）
 * <p>
 * 优点：懒加载（第一次调用才初始化），避免内存浪费，线程安全，能保持高性能
 * <p>
 * 缺点：代码不优雅
 * 可以被 序列化+反序列化 破坏单例，即：json转换
 */
```
## 2.4 LazyStaticInnerClassSingleton 
```java
/**
 * 创建人：Sinon
 * 创建时间：2020/7/20
 * <p>
 * 4.懒汉式单例-静态内部类版
 * java的 类初始加载：
 * 会先加载外部类，即 LazyStaticInnerClassSingleton.class
 * 但不会加载内部类，内部类的路径为：LazyStaticInnerClassSingleton$LazyHolder.class
 * <p>
 * 优点：懒加载（第一次调用才初始化），避免内存浪费，线程安全，能保持高性能
 * 缺点：能被反射破坏
 * 可以被 序列化+反序列化 破坏单例，即：json转换
 */
```
# 3. EnumSingleton
```java
/**
 * 创建人：Sinon
 * 创建时间：2020/7/20
 * <p>
 * 6.枚举式单例
 * <p>
 * 优点：写法优雅，自动支持序列化机制，绝对防止多次实例化
 * <p>
 * 缺点：与饿汉式单例差不多，也是程序初始化时就加载，但是写法更优雅
 * <p>
 * 枚举方法可以有自己的属性、方法；
 * <p>
 * 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，
 * 而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。
 * 不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。
 * 不能通过 reflection attack（反射攻击） 来调用私有构造方法。
 */
```